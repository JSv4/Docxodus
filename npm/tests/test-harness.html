<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Docxodus WASM Test Harness</title>
</head>
<body>
    <h1>Docxodus WASM Test Harness</h1>
    <div id="status">Loading...</div>
    <pre id="output"></pre>

    <script type="module">
        import { dotnet } from './_framework/dotnet.js';

        const { getAssemblyExports, getConfig } = await dotnet
            .withDiagnosticTracing(false)
            .create();

        const config = getConfig();
        const exports = await getAssemblyExports(config.mainAssemblyName);

        // Expose Docxodus APIs to window for testing
        window.Docxodus = {
            DocumentConverter: exports.DocxodusWasm.DocumentConverter,
            DocumentComparer: exports.DocxodusWasm.DocumentComparer
        };

        // Test helper functions
        window.DocxodusTests = {
            // Convert DOCX to HTML
            convertToHtml: function(bytes) {
                try {
                    const result = window.Docxodus.DocumentConverter.ConvertDocxToHtml(bytes);
                    if (result.startsWith('{') && result.includes('"Error"')) {
                        return { error: JSON.parse(result) };
                    }
                    return { html: result };
                } catch (e) {
                    return { error: { message: e.message } };
                }
            },

            // Compare two documents
            compareDocuments: function(originalBytes, modifiedBytes, authorName = 'Test') {
                try {
                    const result = window.Docxodus.DocumentComparer.CompareDocuments(
                        originalBytes, modifiedBytes, authorName
                    );
                    if (result.length === 0) {
                        return { error: { message: 'Comparison returned empty result' } };
                    }
                    return { docxBytes: result };
                } catch (e) {
                    return { error: { message: e.message } };
                }
            },

            // Compare and get HTML (with tracked changes visible by default)
            compareToHtml: function(originalBytes, modifiedBytes, authorName = 'Test') {
                try {
                    const result = window.Docxodus.DocumentComparer.CompareDocumentsToHtml(
                        originalBytes, modifiedBytes, authorName
                    );
                    if (result.startsWith('{') && result.includes('"Error"')) {
                        return { error: JSON.parse(result) };
                    }
                    return { html: result };
                } catch (e) {
                    return { error: { message: e.message } };
                }
            },

            // Compare and get HTML with options
            compareToHtmlWithOptions: function(originalBytes, modifiedBytes, authorName = 'Test', renderTrackedChanges = true) {
                try {
                    const result = window.Docxodus.DocumentComparer.CompareDocumentsToHtmlWithOptions(
                        originalBytes, modifiedBytes, authorName, renderTrackedChanges
                    );
                    if (result.startsWith('{') && result.includes('"Error"')) {
                        return { error: JSON.parse(result) };
                    }
                    return { html: result };
                } catch (e) {
                    return { error: { message: e.message } };
                }
            },

            // Get revisions from compared document
            getRevisions: function(docxBytes) {
                try {
                    const result = window.Docxodus.DocumentComparer.GetRevisionsJson(docxBytes);
                    if (result.startsWith('{') && result.includes('"Error"')) {
                        return { error: JSON.parse(result) };
                    }
                    const parsed = JSON.parse(result);
                    return { revisions: parsed.Revisions || [] };
                } catch (e) {
                    return { error: { message: e.message } };
                }
            },

            // Get version info
            getVersion: function() {
                return JSON.parse(window.Docxodus.DocumentConverter.GetVersion());
            },

            // Convert DOCX to HTML with pagination
            convertToHtmlWithPagination: function(bytes, paginationMode = 1, paginationScale = 1.0) {
                try {
                    const result = window.Docxodus.DocumentConverter.ConvertDocxToHtmlWithPagination(
                        bytes,
                        'Document',      // pageTitle
                        'docx-',         // cssPrefix
                        true,            // fabricateClasses
                        '',              // additionalCss
                        -1,              // commentRenderMode (disabled)
                        'comment-',      // commentCssClassPrefix
                        paginationMode,  // 0=None, 1=Paginated
                        paginationScale, // scale factor
                        'page-'          // paginationCssClassPrefix
                    );
                    if (result.startsWith('{') && result.includes('"Error"')) {
                        return { error: JSON.parse(result) };
                    }
                    return { html: result };
                } catch (e) {
                    return { error: { message: e.message } };
                }
            },

            // Convert DOCX to HTML with annotations
            convertToHtmlWithAnnotations: function(bytes, renderAnnotations = true, annotationLabelMode = 0) {
                try {
                    const result = window.Docxodus.DocumentConverter.ConvertDocxToHtmlFull(
                        bytes,
                        'Document',      // pageTitle
                        'docx-',         // cssPrefix
                        true,            // fabricateClasses
                        '',              // additionalCss
                        -1,              // commentRenderMode (disabled)
                        'comment-',      // commentCssClassPrefix
                        0,               // paginationMode (None)
                        1.0,             // paginationScale
                        'page-',         // paginationCssClassPrefix
                        renderAnnotations,      // renderAnnotations
                        annotationLabelMode,    // annotationLabelMode: 0=Above, 1=Inline, 2=Tooltip, 3=None
                        'annot-'                // annotationCssClassPrefix
                    );
                    if (result.startsWith('{') && result.includes('"Error"')) {
                        return { error: JSON.parse(result) };
                    }
                    return { html: result };
                } catch (e) {
                    return { error: { message: e.message } };
                }
            },

            // Get annotations from a document
            getAnnotations: function(bytes) {
                try {
                    const result = window.Docxodus.DocumentConverter.GetAnnotations(bytes);
                    if (result.startsWith('{') && result.includes('"Error"')) {
                        return { error: JSON.parse(result) };
                    }
                    const parsed = JSON.parse(result);
                    return { annotations: parsed.Annotations || [] };
                } catch (e) {
                    return { error: { message: e.message } };
                }
            },

            // Add an annotation to a document
            addAnnotation: function(bytes, request) {
                try {
                    const requestJson = JSON.stringify(request);
                    const result = window.Docxodus.DocumentConverter.AddAnnotation(bytes, requestJson);
                    if (result.startsWith('{') && result.includes('"Error"')) {
                        return { error: JSON.parse(result) };
                    }
                    const parsed = JSON.parse(result);
                    // Decode base64 document bytes
                    let documentBytes = null;
                    if (parsed.DocumentBytes) {
                        const binaryString = atob(parsed.DocumentBytes);
                        documentBytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            documentBytes[i] = binaryString.charCodeAt(i);
                        }
                    }
                    return {
                        success: parsed.Success,
                        documentBytes: documentBytes,
                        annotation: parsed.Annotation
                    };
                } catch (e) {
                    return { error: { message: e.message } };
                }
            },

            // Remove an annotation from a document
            removeAnnotation: function(bytes, annotationId) {
                try {
                    const result = window.Docxodus.DocumentConverter.RemoveAnnotation(bytes, annotationId);
                    if (result.startsWith('{') && result.includes('"Error"')) {
                        return { error: JSON.parse(result) };
                    }
                    const parsed = JSON.parse(result);
                    // Decode base64 document bytes
                    let documentBytes = null;
                    if (parsed.DocumentBytes) {
                        const binaryString = atob(parsed.DocumentBytes);
                        documentBytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            documentBytes[i] = binaryString.charCodeAt(i);
                        }
                    }
                    return {
                        success: parsed.Success,
                        documentBytes: documentBytes
                    };
                } catch (e) {
                    return { error: { message: e.message } };
                }
            },

            // Check if a document has annotations
            hasAnnotations: function(bytes) {
                try {
                    const result = window.Docxodus.DocumentConverter.HasAnnotations(bytes);
                    if (result.startsWith('{') && result.includes('"Error"')) {
                        return { error: JSON.parse(result) };
                    }
                    const parsed = JSON.parse(result);
                    return { hasAnnotations: parsed.HasAnnotations };
                } catch (e) {
                    return { error: { message: e.message } };
                }
            },

            // Get document structure for element-based annotation targeting
            getDocumentStructure: function(bytes) {
                try {
                    const result = window.Docxodus.DocumentConverter.GetDocumentStructure(bytes);
                    if (result.startsWith('{') && result.includes('"Error"')) {
                        return { error: JSON.parse(result) };
                    }
                    const parsed = JSON.parse(result);
                    return {
                        root: parsed.Root,
                        elementsById: parsed.ElementsById,
                        tableColumns: parsed.TableColumns
                    };
                } catch (e) {
                    return { error: { message: e.message } };
                }
            },

            // Get document metadata for lazy loading (Phase 3)
            getDocumentMetadata: async function(bytes) {
                try {
                    // Yield to browser before WASM work (matching main API behavior)
                    await new Promise(resolve => {
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => resolve(undefined));
                        });
                    });

                    const result = window.Docxodus.DocumentConverter.GetDocumentMetadata(bytes);
                    if (result.startsWith('{') && result.includes('"Error"')) {
                        return { error: JSON.parse(result) };
                    }
                    const parsed = JSON.parse(result);

                    // Convert from PascalCase to camelCase for consistency
                    const convertSection = (s) => ({
                        sectionIndex: s.SectionIndex ?? s.sectionIndex,
                        pageWidthPt: s.PageWidthPt ?? s.pageWidthPt,
                        pageHeightPt: s.PageHeightPt ?? s.pageHeightPt,
                        marginTopPt: s.MarginTopPt ?? s.marginTopPt,
                        marginRightPt: s.MarginRightPt ?? s.marginRightPt,
                        marginBottomPt: s.MarginBottomPt ?? s.marginBottomPt,
                        marginLeftPt: s.MarginLeftPt ?? s.marginLeftPt,
                        contentWidthPt: s.ContentWidthPt ?? s.contentWidthPt,
                        contentHeightPt: s.ContentHeightPt ?? s.contentHeightPt,
                        headerPt: s.HeaderPt ?? s.headerPt,
                        footerPt: s.FooterPt ?? s.footerPt,
                        paragraphCount: s.ParagraphCount ?? s.paragraphCount,
                        tableCount: s.TableCount ?? s.tableCount,
                        hasHeader: s.HasHeader ?? s.hasHeader,
                        hasFooter: s.HasFooter ?? s.hasFooter,
                        hasFirstPageHeader: s.HasFirstPageHeader ?? s.hasFirstPageHeader,
                        hasFirstPageFooter: s.HasFirstPageFooter ?? s.hasFirstPageFooter,
                        hasEvenPageHeader: s.HasEvenPageHeader ?? s.hasEvenPageHeader,
                        hasEvenPageFooter: s.HasEvenPageFooter ?? s.hasEvenPageFooter,
                        startParagraphIndex: s.StartParagraphIndex ?? s.startParagraphIndex,
                        endParagraphIndex: s.EndParagraphIndex ?? s.endParagraphIndex,
                        startTableIndex: s.StartTableIndex ?? s.startTableIndex,
                        endTableIndex: s.EndTableIndex ?? s.endTableIndex,
                    });

                    return {
                        sections: (parsed.Sections || parsed.sections || []).map(convertSection),
                        totalParagraphs: parsed.TotalParagraphs ?? parsed.totalParagraphs,
                        totalTables: parsed.TotalTables ?? parsed.totalTables,
                        hasFootnotes: parsed.HasFootnotes ?? parsed.hasFootnotes,
                        hasEndnotes: parsed.HasEndnotes ?? parsed.hasEndnotes,
                        hasTrackedChanges: parsed.HasTrackedChanges ?? parsed.hasTrackedChanges,
                        hasComments: parsed.HasComments ?? parsed.hasComments,
                        estimatedPageCount: parsed.EstimatedPageCount ?? parsed.estimatedPageCount,
                    };
                } catch (e) {
                    return { error: { message: e.message } };
                }
            },

            // Convert DOCX to HTML with pagination AND tracked changes
            convertToHtmlWithPaginationAndTrackedChanges: function(bytes, paginationMode = 1, paginationScale = 1.0, renderTrackedChanges = true) {
                try {
                    const result = window.Docxodus.DocumentConverter.ConvertDocxToHtmlComplete(
                        bytes,
                        'Document',           // pageTitle
                        'docx-',              // cssPrefix
                        true,                 // fabricateClasses
                        '',                   // additionalCss
                        -1,                   // commentRenderMode (disabled)
                        'comment-',           // commentCssClassPrefix
                        paginationMode,       // 0=None, 1=Paginated
                        paginationScale,      // scale factor
                        'page-',              // paginationCssClassPrefix
                        false,                // renderAnnotations
                        0,                    // annotationLabelMode
                        'annot-',             // annotationCssClassPrefix
                        true,                 // renderFootnotesAndEndnotes
                        true,                 // renderHeadersAndFooters
                        renderTrackedChanges, // renderTrackedChanges
                        true,                 // showDeletedContent
                        true                  // renderMoveOperations
                    );
                    if (result.startsWith('{') && result.includes('"Error"')) {
                        return { error: JSON.parse(result) };
                    }
                    return { html: result };
                } catch (e) {
                    return { error: { message: e.message } };
                }
            },

            // Add annotation with flexible targeting
            addAnnotationWithTarget: function(bytes, request) {
                try {
                    const requestJson = JSON.stringify(request);
                    const result = window.Docxodus.DocumentConverter.AddAnnotationWithTarget(bytes, requestJson);
                    if (result.startsWith('{') && result.includes('"Error"')) {
                        return { error: JSON.parse(result) };
                    }
                    const parsed = JSON.parse(result);
                    // Decode base64 document bytes
                    let documentBytes = null;
                    if (parsed.DocumentBytes) {
                        const binaryString = atob(parsed.DocumentBytes);
                        documentBytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            documentBytes[i] = binaryString.charCodeAt(i);
                        }
                    }
                    return {
                        success: documentBytes != null,  // Success if we have document bytes
                        documentBytes: documentBytes,
                        annotation: parsed.Annotation
                    };
                } catch (e) {
                    return { error: { message: e.message } };
                }
            },

            // Render a specific page range for lazy loading/virtual scrolling
            renderPageRange: function(bytes, startPage, endPage, options = {}) {
                try {
                    const result = window.Docxodus.DocumentConverter.RenderPageRange(
                        bytes,
                        startPage,
                        endPage,
                        options.pageTitle || 'Document',
                        options.cssPrefix || 'docx-',
                        options.fabricateClasses !== false,
                        options.paginationScale || 1.0,
                        options.paginationCssClassPrefix || 'page-',
                        options.renderFootnotesAndEndnotes || false,
                        options.renderHeadersAndFooters || false
                    );
                    if (result.startsWith('{') && result.includes('"Error"')) {
                        return { error: JSON.parse(result) };
                    }
                    return { html: result };
                } catch (e) {
                    return { error: { message: e.message } };
                }
            },

            /**
             * Virtual Scroll Container - implements true virtualization with on-demand page loading
             *
             * This creates a scrollable viewport that:
             * 1. Initially loads only the first 2 pages
             * 2. Shows placeholders for unloaded pages
             * 3. Loads pages on-demand when placeholders scroll into view
             * 4. Tracks which pages are loaded for verification
             */
            virtualScrollState: null,

            createVirtualScrollContainer: async function(bytes, viewportHeight = 400) {
                const self = this;

                // Get document metadata first
                const metadata = await this.getDocumentMetadata(bytes);
                if (metadata.error) {
                    return { error: metadata.error };
                }

                const totalPages = metadata.estimatedPageCount;
                const pageHeight = 600; // Estimated page height in pixels

                // Initialize state
                this.virtualScrollState = {
                    bytes: bytes,
                    totalPages: totalPages,
                    loadedPages: new Set(),
                    loadEvents: [], // Track when pages are loaded
                    viewportHeight: viewportHeight,
                    pageHeight: pageHeight
                };

                // Create container HTML
                const containerHtml = `
                    <style>
                        #virtual-scroll-viewport {
                            height: ${viewportHeight}px;
                            overflow-y: auto;
                            border: 2px solid #333;
                            position: relative;
                        }
                        #virtual-scroll-content {
                            position: relative;
                        }
                        .page-placeholder {
                            height: ${pageHeight}px;
                            background: linear-gradient(135deg, #f0f0f0 25%, #e8e8e8 50%, #f0f0f0 75%);
                            border-bottom: 1px dashed #ccc;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-family: sans-serif;
                            color: #666;
                        }
                        .page-container {
                            min-height: ${pageHeight}px;
                            border-bottom: 1px solid #ddd;
                        }
                        .page-loaded {
                            background: #fff;
                        }
                        .load-indicator {
                            position: fixed;
                            top: 10px;
                            right: 10px;
                            background: rgba(0,0,0,0.8);
                            color: white;
                            padding: 10px;
                            border-radius: 5px;
                            font-family: monospace;
                            font-size: 12px;
                            z-index: 1000;
                        }
                    </style>
                    <div id="load-indicator" class="load-indicator">
                        Pages loaded: <span id="pages-loaded-count">0</span>/${totalPages}
                    </div>
                    <div id="virtual-scroll-viewport">
                        <div id="virtual-scroll-content">
                            ${Array.from({length: totalPages}, (_, i) => `
                                <div class="page-container" data-page="${i + 1}" id="page-container-${i + 1}">
                                    <div class="page-placeholder" data-page="${i + 1}">
                                        Loading Page ${i + 1}...
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;

                return {
                    html: containerHtml,
                    totalPages: totalPages,
                    viewportHeight: viewportHeight,
                    pageHeight: pageHeight
                };
            },

            // Load a specific page into the virtual scroll container
            loadPage: async function(pageNumber) {
                const state = this.virtualScrollState;
                if (!state || state.loadedPages.has(pageNumber)) {
                    return { alreadyLoaded: true };
                }

                try {
                    // Render just this one page
                    const result = this.renderPageRange(state.bytes, pageNumber, pageNumber);
                    if (result.error) {
                        return { error: result.error };
                    }

                    // Extract just the body content (skip the full HTML wrapper)
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(result.html, 'text/html');
                    const bodyContent = doc.body.innerHTML;

                    // Find the page container and update it
                    const container = document.getElementById(`page-container-${pageNumber}`);
                    if (container) {
                        container.innerHTML = bodyContent;
                        container.classList.add('page-loaded');
                    }

                    // Track the load
                    state.loadedPages.add(pageNumber);
                    state.loadEvents.push({
                        page: pageNumber,
                        timestamp: Date.now()
                    });

                    // Update indicator
                    const indicator = document.getElementById('pages-loaded-count');
                    if (indicator) {
                        indicator.textContent = state.loadedPages.size.toString();
                    }

                    return {
                        loaded: true,
                        page: pageNumber,
                        loadedPages: Array.from(state.loadedPages).sort((a, b) => a - b)
                    };
                } catch (e) {
                    return { error: { message: e.message } };
                }
            },

            // Set up IntersectionObserver for lazy loading
            setupLazyLoading: function() {
                const self = this;
                const state = this.virtualScrollState;
                if (!state) return;

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const pageNum = parseInt(entry.target.dataset.page, 10);
                            if (!state.loadedPages.has(pageNum)) {
                                self.loadPage(pageNum);
                            }
                        }
                    });
                }, {
                    root: document.getElementById('virtual-scroll-viewport'),
                    rootMargin: '100px', // Load pages slightly before they're visible
                    threshold: 0.1
                });

                // Observe all page placeholders
                document.querySelectorAll('.page-placeholder').forEach(placeholder => {
                    observer.observe(placeholder);
                });

                return { observerSetup: true };
            },

            // Get current virtual scroll state
            getVirtualScrollState: function() {
                const state = this.virtualScrollState;
                if (!state) return { error: { message: 'No virtual scroll state' } };

                return {
                    totalPages: state.totalPages,
                    loadedPages: Array.from(state.loadedPages).sort((a, b) => a - b),
                    loadEvents: state.loadEvents,
                    unloadedPages: Array.from({length: state.totalPages}, (_, i) => i + 1)
                        .filter(p => !state.loadedPages.has(p))
                };
            },

            // Scroll to a specific page
            scrollToPage: function(pageNumber) {
                const state = this.virtualScrollState;
                if (!state) return { error: { message: 'No virtual scroll state' } };

                const viewport = document.getElementById('virtual-scroll-viewport');
                if (!viewport) return { error: { message: 'Viewport not found' } };

                const targetScroll = (pageNumber - 1) * state.pageHeight;
                viewport.scrollTo({ top: targetScroll, behavior: 'instant' });

                return {
                    scrolledTo: pageNumber,
                    scrollTop: targetScroll
                };
            }
        };

        document.getElementById('status').textContent = 'Ready';
        window.DocxodusReady = true;
        console.log('Docxodus WASM Test Harness Ready');
        console.log('Version:', window.DocxodusTests.getVersion());
    </script>
</body>
</html>
